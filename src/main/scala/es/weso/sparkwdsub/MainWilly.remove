package es.weso.sparkwdsub

package es.weso.sparkwdsub

import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}
import org.wikidata.wdtk.datamodel.helpers.JsonDeserializer
import org.wikidata.wdtk.datamodel.implementation.ItemDocumentImpl

// spark-submit "--master local[*] --class es.weso.wqsub.MeanOutDegree /gfs/home/thewillyhuman/labra-wsub/spark-jobs/wqsub-spark/wqsub-spark-assembly-1.0.jar /gfs/projects/weso-scholia/dumps/latest-all.json"
object MeanOutDegree {

  def main(args: Array[String]): Unit = {

    if (args.size < 1) {
      println( "Please provide the dump path" )
      System.exit( -1 )
    }

    // Get the dump path from the arguments.
    val dumpPath = args(0)

    // Init the spark session.
    val sparkConf = 
        new SparkConf()
        .setAppName( "wqsub_compute_avg_out_degree" )
        .setMaster("local")

    //val spark = SparkSession.builder()
    //  .master("local[*]")
    //  .appName("wqsub_compute_avg_out_degree")
    //  .getOrCreate();

    // Init the spark context
    val sc = new SparkContext( sparkConf )

    // Get all the dump lines that are not "[" "]" (Start and end of the JSON array.)
    val dumpLines: RDD[String] = sc.textFile( dumpPath )
      .filter( line => !line.contentEquals( "[" ) )
      .filter( line => !line.contentEquals( "]" ) )

    // Deserialize each line in to an entity document object.
    val entityDocuments = dumpLines.map( line => {
      val jsonDeserializer = new JsonDeserializer( "http://www.wikidata.org/entity/" )
      jsonDeserializer.deserializeEntityDocument( line )
    } )

    val itemDocuments = entityDocuments.filter( entityDocument => entityDocument.isInstanceOf[ItemDocumentImpl] )
      .map( entityDocument => entityDocument.asInstanceOf[ItemDocumentImpl] )

    println(itemDocuments.collect().map(_.toString).mkString("\n"))

    // Get the out degree of each item document.
    val outDegrees: RDD[Int] = itemDocuments.map( itemDocument => itemDocument.getStatementGroups.size() )

    // Compute the average out degree. It is computed as the addition of all the degrees over the total number
    // of items in the dataset.
    val numberOfNodes = itemDocuments.count()
    val totalNumberOfOutDegrees = outDegrees.reduce( _ + _ )
    val result: Double = totalNumberOfOutDegrees.toLong.asInstanceOf[Double] / numberOfNodes.asInstanceOf[Double]

    println( s"Total Out Degree -> $totalNumberOfOutDegrees" )
    println( s"Total Number of Items -> $numberOfNodes" )
    println( s"Average Out Degree -> $result" )

    // Ideally save the results to a file...
  }
}